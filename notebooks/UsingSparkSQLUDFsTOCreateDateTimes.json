{"paragraphs":[{"text":"%md\nDefining our udf is pretty easy, we just create an anonymous function and register it through the SqlContextor through the udf function in org.apache.spark.sql.functions.udfdepending on how you want to use it. Here's the set up. Imagine purchases is a DataFrame in the layout of:\n* customer\\_id\n* purchase\\_id\n* date\n* time\n* tz\n* amount\n\nOur goal here is to actually get a datetime field that we can use, Let's go ahead and give it a shot.","dateUpdated":"May 19, 2016 3:55:10 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673215273_928508518","id":"20160519-155335_1848661547","result":{"code":"SUCCESS","type":"HTML","msg":"<p>Defining our udf is pretty easy, we just create an anonymous function and register it through the SqlContextor through the udf function in org.apache.spark.sql.functions.udfdepending on how you want to use it. Here's the set up. Imagine purchases is a DataFrame in the layout of:</p>\n<ul>\n<li>customer_id</li>\n<li>purchase_id</li>\n<li>date</li>\n<li>time</li>\n<li>tz</li>\n<li>amount</li>\n</ul>\n<p>Our goal here is to actually get a datetime field that we can use, Let's go ahead and give it a shot.</p>\n"},"dateCreated":"May 19, 2016 3:53:35 PM","dateStarted":"May 19, 2016 3:55:06 PM","dateFinished":"May 19, 2016 3:55:06 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:38"},{"text":"case class Purchase(customer_id: Int, purchase_id: Int, date: String, time: String, tz: String, amount:Double)\n\nval x = sc.parallelize(Array(\n  Purchase(123, 234, \"2007-12-12\", \"20:50\", \"UTC\", 500.99),\n  Purchase(123, 247, \"2007-12-12\", \"15:30\", \"PST\", 300.22),\n  Purchase(189, 254, \"2007-12-13\", \"00:50\", \"EST\", 122.19),\n  Purchase(187, 299, \"2007-12-12\", \"07:30\", \"UTC\", 524.37)\n))\n\nval df = sqlContext.createDataFrame(x)\ndf.registerTempTable(\"df\")","dateUpdated":"May 19, 2016 3:55:24 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673287274_409790379","id":"20160519-155447_1565071536","result":{"code":"SUCCESS","type":"TEXT","msg":"defined class Purchase\nx: org.apache.spark.rdd.RDD[Purchase] = ParallelCollectionRDD[591] at parallelize at <console>:40\ndf: org.apache.spark.sql.DataFrame = [customer_id: int, purchase_id: int, date: string, time: string, tz: string, amount: double]\n"},"dateCreated":"May 19, 2016 3:54:47 PM","dateStarted":"May 19, 2016 3:55:24 PM","dateFinished":"May 19, 2016 3:55:27 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:39"},{"title":"Now let's define our functions! The underscores simply signify that it's a partially applied function.","text":"def makeDT(date: String, time: String, tz: String) = s\"$date $time $tz\"\nsqlContext.udf.register(\"makeDt\", makeDT(_:String,_:String,_:String))\n\n// Now we can use our function directly in SparkSQL.\nsqlContext.sql(\"SELECT amount, makeDt(date, time, tz) from df\").take(2)\n","dateUpdated":"May 19, 2016 3:56:32 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"title":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673324811_-917331171","id":"20160519-155524_1514801962","result":{"code":"SUCCESS","type":"TEXT","msg":"makeDT: (date: String, time: String, tz: String)String\nres44: org.apache.spark.sql.UserDefinedFunction = UserDefinedFunction(<function3>,StringType,List(StringType, StringType, StringType))\nres47: Array[org.apache.spark.sql.Row] = Array([500.99,2007-12-12 20:50 UTC], [300.22,2007-12-12 15:30 PST])\n"},"dateCreated":"May 19, 2016 3:55:24 PM","dateStarted":"May 19, 2016 3:56:06 PM","dateFinished":"May 19, 2016 3:56:07 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:40"},{"title":"Fails when using outside of SparkSQL!","text":"// but not outside\ndf.select($\"customer_id\", makeDt($\"date\", $\"time\", $\"tz\"), $\"amount\").take(2) // fails","dateUpdated":"May 19, 2016 3:57:30 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"title":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673366264_-883980610","id":"20160519-155606_282911734","result":{"code":"ERROR","type":"TEXT","msg":"<console>:45: error: not found: value makeDt\n              df.select($\"customer_id\", makeDt($\"date\", $\"time\", $\"tz\"), $\"amount\").take(2) // fails\n                                        ^\n"},"dateCreated":"May 19, 2016 3:56:06 PM","dateStarted":"May 19, 2016 3:56:59 PM","dateFinished":"May 19, 2016 3:56:59 PM","status":"ERROR","progressUpdateIntervalMs":500,"$$hashKey":"object:41"},{"text":"%md\nYou can see above that we can use it within SQL but not outside of it. To do that we're going to have to create a different UDF using spark.sql.function.udf","dateUpdated":"May 19, 2016 3:57:48 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/markdown","editorHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673373312_686964474","id":"20160519-155613_1115509543","result":{"code":"SUCCESS","type":"HTML","msg":"<p>You can see above that we can use it within SQL but not outside of it. To do that we're going to have to create a different UDF using spark.sql.function.udf</p>\n"},"dateCreated":"May 19, 2016 3:56:13 PM","dateStarted":"May 19, 2016 3:57:45 PM","dateFinished":"May 19, 2016 3:57:45 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:42"},{"text":"import org.apache.spark.sql.functions.udf\nval makeDt = udf(makeDT(_:String,_:String,_:String))\n// now this works\ndf.select($\"customer_id\", makeDt($\"date\", $\"time\", $\"tz\"), $\"amount\").take(2)","dateUpdated":"May 19, 2016 3:58:58 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673465672_220153500","id":"20160519-155745_628027565","result":{"code":"SUCCESS","type":"TEXT","msg":"import org.apache.spark.sql.functions.udf\nmakeDt: org.apache.spark.sql.UserDefinedFunction = UserDefinedFunction(<function3>,StringType,List(StringType, StringType, StringType))\nres54: Array[org.apache.spark.sql.Row] = Array([123,2007-12-12 20:50 UTC,500.99], [123,2007-12-12 15:30 PST,300.22])\n"},"dateCreated":"May 19, 2016 3:57:45 PM","dateStarted":"May 19, 2016 3:58:58 PM","dateFinished":"May 19, 2016 3:58:59 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:43"},{"text":"%md\n ##We're really just joining these fields together. Now we can see that it's working however we've still got a string representation. In Spark version 1.5, functions to create date times were introduced.\n https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.functions$\n##Now we can leave our function the same however we're just going to create a format and wrap our MakeDT function in the unix_timestampfunction call, we can do this both in and out of SparkSQL! ","dateUpdated":"May 19, 2016 4:00:24 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/markdown"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673538205_-393982366","id":"20160519-155858_1497549854","result":{"code":"SUCCESS","type":"HTML","msg":"<h2>We're really just joining these fields together. Now we can see that it's working however we've still got a string representation. In Spark version 1.5, functions to create date times were introduced.</h2>\n<p>https://spark.apache.org/docs/latest/api/scala/index.html#org.apache.spark.sql.functions$</p>\n<h2>Now we can leave our function the same however we're just going to create a format and wrap our MakeDT function in the unix_timestampfunction call, we can do this both in and out of SparkSQL!</h2>\n"},"dateCreated":"May 19, 2016 3:58:58 PM","dateStarted":"May 19, 2016 4:00:24 PM","dateFinished":"May 19, 2016 4:00:24 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:44"},{"text":"import org.apache.spark.sql.functions.unix_timestamp\n\nval fmt = \"yyyy-MM-dd hh:mm z\"\ndf.select($\"customer_id\", unix_timestamp(makeDt($\"date\", $\"time\", $\"tz\"), fmt), $\"amount\").take(2)\nsqlContext.sql(s\"SELECT customer_id, unix_timestamp(makeDt(date, time, tz), '$fmt'), amount FROM df\").take(2)","dateUpdated":"May 19, 2016 4:01:03 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673599868_-503358323","id":"20160519-155959_744083437","result":{"code":"SUCCESS","type":"TEXT","msg":"import org.apache.spark.sql.functions.unix_timestamp\nfmt: String = yyyy-MM-dd hh:mm z\nres57: Array[org.apache.spark.sql.Row] = Array([123,1197492600,500.99], [123,1197502200,300.22])\nres58: Array[org.apache.spark.sql.Row] = Array([123,1197492600,500.99], [123,1197502200,300.22])\n"},"dateCreated":"May 19, 2016 3:59:59 PM","dateStarted":"May 19, 2016 4:01:03 PM","dateFinished":"May 19, 2016 4:01:04 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:45"},{"text":"%md\nCredit: Using SparkSQL UDFs to Create Date Times in Spark 1.5\nhttp://www.sparktutorials.net/using-sparksql-udfs-to-create-date-times-in-spark-1.5","dateUpdated":"May 19, 2016 4:02:08 PM","config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/markdown","editorHide":false,"tableHide":true},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673663403_-1776584378","id":"20160519-160103_1776752765","result":{"code":"SUCCESS","type":"HTML","msg":"<p>Credit: Using SparkSQL UDFs to Create Date Times in Spark 1.5\n<br  />http://www.sparktutorials.net/using-sparksql-udfs-to-create-date-times-in-spark-1.5</p>\n"},"dateCreated":"May 19, 2016 4:01:03 PM","dateStarted":"May 19, 2016 4:01:56 PM","dateFinished":"May 19, 2016 4:01:57 PM","status":"FINISHED","progressUpdateIntervalMs":500,"$$hashKey":"object:46"},{"config":{"colWidth":12,"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true,"editorMode":"ace/mode/scala"},"settings":{"params":{},"forms":{}},"jobName":"paragraph_1463673682669_-1940856834","id":"20160519-160122_1571368691","dateCreated":"May 19, 2016 4:01:22 PM","status":"READY","progressUpdateIntervalMs":500,"$$hashKey":"object:47"}],"name":"Using SparkSQL UDFs to Create Date Times ","id":"2BKGKEKYD","angularObjects":{"2BCKC8XEM":[],"2BCX68DXU":[],"2BFBT15Z1":[],"2BESYJRTZ":[],"2BCBP9D5X":[],"2BDTPNC5U":[],"2BF9DMDST":[],"2BEA4YGRP":[],"2BEP4GTHY":[],"2BD3W8Y9X":[],"2BEJY9WFY":[],"2BCSDJUE3":[],"2BEPFKEXV":[]},"config":{"looknfeel":"default"},"info":{}}